{
    "input": "Universidad Auto´noma de Baja California\nFacultad de Ingenier´ıa\nPr´actica # 1 - System Calls\nSistemas Operativos\n1176461\nHector Jesus Duran Cardenas\nMexicali, B.C. a 26 de Septiembre del 20241 Introduccio´n\nComousuariosdesistemasoperativosyprogramadores, adiariointeractuamosdeformatantodirectacomo\nindirecta con las Llamada al Sistema. Estas son uno de los mecanismos ofrecidos por el sistema operativo\nque, de haber realizado programas en lenguaje C, puede que hayamos hecho uso de ellas sin saberlo. Es\npor ello que, en esta pr´actica, se realizar´a un programa en C que actu´e como un int´erprete de comandos\nenfocado u´nicamente en llevar a cabo funciones de manejo de archivos por medio de APIs que invoquen a\nlas Llamadas al Sistema necesarias para llevar a cabo cada una de las funciones.\n2 Objetivo\nIdentificar los elementos que componen un sistema operativo, mediante el estudio de su definici´on, su\nevoluci´on,componentesytiposparareconocerlaimportanciadelainteracci´ondeestos,conactitudanal´ıtica\ny trabajo colaborativo.\n3 Fundamento\nLas Llamadas al Sistema (System Calls) son un mecanismo que provee de una interfaz a los servicios que\nproporciona un sistema operativo. Este mecanismo suele verse como un conjunto de funciones en lenguaje\nC/C++. Sindarnoscuenta,elsistemaejecutamilesdeSystemCallsporsegundoy,paraqueunprogramador\npuedahacerusodemanerasencilladeesta, puedeapoyarsedelasAPI(applicationprogramminginterface).\nEstas API especifican un conjunto de funciones que est´an disponibles por medio de una librer´ıa.\n4 Procedimiento\nEl alumno deber´a realizar un int´erprete de comandos en C haciendo uso de llamadas al sistema. Este\nint´erprete deber´a ser capaz de realizar las tareas de abrir y mostrar un archivo de texto, copiar el contenido\nde un archivo de texto existente en un archivo nuevo, creando el archivo copia en caso de ser necesario,\ncrear un nuevo archivo de texto y eliminar un archivo existente por medio de comandos propios y haciendo\nuso de las llamadas al sistema respectivas para el cumplimiento de cada tarea. El int´erprete deber´a seguir\nfuncionando despu´es de haber realizado un comando, deteniendo su ejecuci´on hasta que el usuario desee\nterminar el proceso o bien, se cierre la consola.\n• abrir y mostrar archivos de texto:\n• mostrarcriaturas: elprogramamostraratodaslascriaturasguardadasenelarchivo,primerosecargan\nlas criaturas del archivo en una lista y luego se muestran en pantallas.\n• eliminarcriatura: elprogramaeliminaradeunarchivocriaturasquecumplanconlaclaveespecificada,\npara ello se cargan las criaturas del archivo a una lista para luego ser eliminadas.\n1a continuaci´on se muestra el c´odigo para mostrar el contenido del archivo y un ejemplo de ejecuci´on\nvoid abrir mostrar archivo(const char∗ nombre archivo) {\nint fd = open(nombre archivo , ORDONLY);\nif (fd == −1) {\nperror(”Error al abrir archivo”);\nreturn;\n}\nchar buffer [BUFFER SIZE];\nssize t bytes leidos ;\nwhile ((bytes leidos = read(fd , buffer , BUFFER SIZE)) > 0) {\nwrite(STDOUTFILENO, buffer , bytes leidos);\n}\nclose(fd);\n}\n}\nFig. 1: ejemplo de ejecuci´on del c´odigo\n2Las siguientes l´ıneas se utilizan para crear un archivo y escribir en el\nvoid mycat command(const char∗ filename) {\n// Abrir el archivo usando la llamada al sistema open()\nint file = open(filename , OWRONLY | OCREAT | OTRUNC, 0644);\nif ( file < 0) {\nperror(”Error al abrir el archivo”);\nreturn;\n}\nchar line [MAXLINELENGTH];\nssize t bytes written;\nprintf(”Entrando en modo de escritura (finaliza con $):\\n”);\nwhile (1) {\n// Leer la entrada del usuario\nif (fgets(line , MAXLINELENGTH, stdin) == NULL) {\nperror(”Error al leer la entrada”);\nclose( file );\nreturn;\n}\n// Comprobar si la l nea contiene solo ’$\\n’\nif (strcmp(line , ”$\\n”) == 0) {\nbreak; // Salir del modo de captura\n}\n// Escribir la l nea en el archivo usando la llamada al sistema write\n()\nbytes written = write(file , line , strlen(line));\nif (bytes written < 0) {\nperror(”Error al escribir en el archivo”);\nclose( file );\nreturn;\n}\n}\n// Cerrar el archivo usando la llamada al sistema close()\nclose( file );\nprintf(”Texto guardado en %s\\n”, filename);\n}\n}\nse mostrara una imagen de ejemplo, para demostrar su utilizaci´on\nFig. 2: ejemplo de uso de la funci´on de crear el archivo y escribir en el\n3a continuaci´on, se mostrara el c´odigo para copiar el contenido del archivo en otro\nvoid copiar archivo(const char∗ origen , const char∗ destino) {\nint fd origen = open(origen , ORDONLY);\nif (fd origen == −1) {\nperror(”Error al abrir archivo origen”);\nreturn;\n}\nint fd destino = open(destino , OWRONLY | OCREAT | OTRUNC, 0644);\nif (fd destino == −1) {\nperror(”Error al crear archivo destino”);\nclose(fd origen);\nreturn;\n}\nchar buffer [MAXLINELENGTH];\nssize t bytes leidos ;\nwhile ((bytes leidos = read(fd origen , buffer , MAXLINELENGTH)) > 0) {\nwrite(fd destino , buffer , bytes leidos);\n}\nclose(fd origen);\nclose(fd destino);\n}\n}\nFig. 3: ejemplo de utilizaci´on del comando para copiar el contenido un archivo en otro\n4y la ultima opci´on del programa es eliminar el archivo especificado\nas´ı seria un ejemplo se su utilizaci´on\nFig. 4: ejemplo de uso de la funci´on de eliminar\na continuaci´on, se mostrara el c´odigo para eliminar el contenido del archivo\nvoid eliminar archivo(const char∗ nombre archivo) {\nif (unlink(nombre archivo) == −1) {\nperror(”Error al eliminar archivo”);\n}\n}\n55 Conclusio´n\nEn esta practica, se reforzaron los conceptos fundamentales de la programaci´on en C, particularmente en el\n´ambito de la manipulaci´on de archivos a bajo nivel, utilizando llamadas al sistema como open(), write(), y\nclose(). Se implement´o un programa que permite realizar operaciones b´asicas de manipulaci´on de archivos\nde texto, como abrir, mostrar y escribir en archivos, proporcionando una interfaz interactiva que permite al\nusuario controlar estas operaciones directamente desde la l´ınea de comandos.\nAdem´as, el programa facilita un mayor entendimiento de c´omo el sistema operativo maneja los archivos\na nivel de sistema, brindando un control detallado sobre la entrada y salida mediante la interacci´on con\nserviciosdelsistemaUnix. Esteenfoquedirectopermitealprogramadorgestionareficientementelacreaci´on\ny modificaci´on de archivos, mejorando tanto la comprensi´on te´orica como pr´actica de la manipulaci´on de\narchivos en entornos de sistemas operativos basados en Linux.\nPoru´ltimo,seaplicaronprincipiosfundamentalesdegesti´onderecursos,utilizandofuncionescomoclose()\npara liberar los descriptores de archivos y prevenir errores de manejo de recursos, asegurando una correcta\ny eficiente interacci´on con el sistema operativo.\n6 Referencias\n67 Anexos\n#include <stdio .h>\n#include <stdlib .h>\n#include <string .h>\n#include <unistd.h>\n#include <fcntl .h>\n#define MAXLINELENGTH 1024\nvoid mycat command(const char∗ filename) {\n// Abrir el archivo usando la llamada al sistema open()\nint file = open(filename , OWRONLY | OCREAT | OTRUNC, 0644);\nif ( file < 0) {\nperror(”Error(cid:32) al (cid:32) abrir (cid:32) el (cid:32)archivo”);\nreturn;\n}\nchar line [MAXLINELENGTH];\nssize t bytes written;\nprintf(”Entrando(cid:32)en(cid:32)modo(cid:32)de(cid:32) escritura (cid:32)(finaliza (cid:32)con(cid:32)$):\\n”);\nwhile (1) {\n// Leer la entrada del usuario\nif (fgets(line , MAXLINELENGTH, stdin) == NULL) {\nperror(”Error(cid:32) al (cid:32) leer (cid:32) la (cid:32)entrada”);\nclose( file );\nreturn;\n}\n// Comprobar si la l nea contiene solo ’$\\n’\nif (strcmp(line , ”$\\n”) == 0) {\nbreak; // Salir del modo de captura\n}\n// Escribir la l nea en el archivo usando la llamada al sistema write()\nbytes written = write(file , line , strlen(line ));\nif (bytes written < 0) {\nperror(”Error(cid:32) al (cid:32) escribir (cid:32)en(cid:32) el (cid:32)archivo”);\nclose( file );\nreturn;\n}\n}\n// Cerrar el archivo usando la llamada al sistema close()\nclose( file );\nprintf(”Texto(cid:32)guardado(cid:32)en(cid:32)%s\\n”, filename );\n}\nvoid abrir mostrar archivo(const char∗ nombre archivo) {\nint fd = open(nombre archivo , ORDONLY);\nif (fd == −1) {\nperror(”Error(cid:32) al (cid:32) abrir (cid:32)archivo”);\nreturn;\n7}\nchar buffer [MAXLINELENGTH];\nssize t bytes leidos ;\nwhile ((bytes leidos = read(fd , buffer , MAXLINELENGTH)) > 0) {\nwrite(STDOUTFILENO, buffer , bytes leidos );\n}\nclose(fd);\n}\n// Funci n para copiar un archivo\nvoid copiar archivo(const char∗ origen , const char∗ destino) {\nint fd origen = open(origen , ORDONLY);\nif (fd origen == −1) {\nperror(”Error(cid:32) al (cid:32) abrir (cid:32)archivo(cid:32)origen”);\nreturn;\n}\nint fd destino = open(destino , OWRONLY | OCREAT | OTRUNC, 0644);\nif (fd destino == −1) {\nperror(”Error(cid:32) al (cid:32)crear(cid:32)archivo(cid:32)destino”);\nclose(fd origen );\nreturn;\n}\nchar buffer [MAXLINELENGTH];\nssize t bytes leidos ;\nwhile ((bytes leidos = read(fd origen , buffer , MAXLINELENGTH)) > 0) {\nwrite(fd destino , buffer , bytes leidos );\n}\nclose(fd origen );\nclose(fd destino );\n}\nvoid eliminar archivo(const char∗ nombre archivo) {\nif (unlink(nombre archivo) == −1) {\nperror(”Error(cid:32) al (cid:32)eliminar(cid:32)archivo”);\n}\n}\nint main() {\nchar command[MAXLINELENGTH];\nchar filename1[MAXLINELENGTH] ,filename2[MAXLINELENGTH];\nwhile(1){\nprintf(”Ingrese(cid:32)comando:\\n”);\nfgets(command, MAXLINELENGTH, stdin );\n// Verificar si el comando empieza con ”mycat>”\nif (sscanf(command, ”mycat>(cid:32)%s”, filename1) == 1) {\nmycat command(filename1 );\n} else if(sscanf(command, ”mycat(cid:32)%s”,filename1)== 1) {\nabrir mostrar archivo(filename1 );\n}else if (sscanf(command, ”mycp(cid:32)%s(cid:32)%s”,filename1 ,filename2)==2){\n8copiar archivo(filename1 ,filename2 );\n}else if(sscanf(command,”remove(cid:32)%s”,filename1)==1){\neliminar archivo(filename1 );\n}else if(sscanf(command,”exit\\n”)==0){\nbreak;\n}else{\nprintf(”Comando(cid:32)no(cid:32)reconocido.\\n”);\n}\n}\nreturn 0;\n}\n9"
}